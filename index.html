<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-R6VKLV1DY9"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-R6VKLV1DY9');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eclipse & Dawn</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lato:wght@400;700&display=swap');

        body {
            font-family: 'Lato', sans-serif;
            overflow: hidden;
            transition: background-color 1.5s ease;
        }

        h1, h2, h3, .fantasy-font {
            font-family: 'Cinzel', serif;
        }

        /* Board Perspective */
        .board-container {
            transform: perspective(1000px) rotateX(15deg);
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }
        
        @media (max-width: 768px) {
            .board-container {
                transform: none; /* Flatten on mobile for better touch targets */
            }
        }

        /* Tile Styles */
        .tile {
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tile:hover {
            filter: brightness(1.2);
            z-index: 10;
        }

        /* Game Piece Animations */
        .piece {
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .piece-enter {
            animation: dropIn 0.5s ease-out;
        }

        @keyframes dropIn {
            0% { opacity: 0; transform: translateY(-50px) scale(1.5); }
            100% { opacity: 1; transform: translateY(0) scale(1); }
        }

        .highlight-move {
            background-color: rgba(34, 197, 94, 0.3); /* Green tint */
            box-shadow: inset 0 0 15px rgba(34, 197, 94, 0.6);
        }
        
        .highlight-attack {
            background-color: rgba(239, 68, 68, 0.3); /* Red tint */
            box-shadow: inset 0 0 15px rgba(239, 68, 68, 0.6);
        }

        .selected-tile {
            box-shadow: inset 0 0 0 4px #fbbf24;
        }

        /* Dynamic Backgrounds */
        .bg-phase-dawn { background: linear-gradient(135deg, #2c3e50, #fd746c); }
        .bg-phase-day { background: linear-gradient(135deg, #fceabb, #f8b500); }
        .bg-phase-dusk { background: linear-gradient(135deg, #4b6cb7, #182848); }
        .bg-phase-night { background: linear-gradient(135deg, #0f2027, #203a43, #2c5364); }
        .bg-phase-eclipse { background: linear-gradient(135deg, #232526, #414345); }

        /* UI Elements */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
        }

        .btn-fantasy {
            transition: all 0.3s ease;
        }
        .btn-fantasy:hover {
            transform: scale(1.05);
            filter: brightness(1.2);
        }
        
        /* Loading Spinner */
        .loader {
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left-color: #fbbf24;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center text-white bg-phase-dawn transition-colors duration-1000" id="gameBody">

    <!-- Modal: Menu -->
    <div id="startModal" class="absolute inset-0 z-50 flex items-center justify-center bg-black/80 backdrop-blur-sm">
        <div class="glass-panel p-8 rounded-2xl max-w-lg text-center mx-4 w-full">
            <h1 class="text-5xl mb-2 text-yellow-400">Eclipse & Dawn</h1>
            <p class="text-xl italic text-gray-300 mb-8">A Strategic Battle for Celestial Dominance</p>
            
            <!-- Main Menu Buttons -->
            <div id="mainMenu" class="space-y-4">
                <button onclick="showDifficultySelect()" class="btn-fantasy w-full bg-gradient-to-r from-blue-600 to-purple-600 text-white font-bold py-4 px-8 rounded-xl shadow-lg text-xl fantasy-font flex items-center justify-center gap-3">
                    <span>ü§ñ</span> VS Computer
                </button>
                <button onclick="startGame('pvp')" class="btn-fantasy w-full bg-gradient-to-r from-yellow-500 to-orange-600 text-white font-bold py-4 px-8 rounded-xl shadow-lg text-xl fantasy-font flex items-center justify-center gap-3">
                    <span>üë•</span> Pass & Play
                </button>
                
                <div class="text-left bg-black/40 p-4 rounded-lg mt-6 space-y-2 text-xs text-gray-400">
                    <p><strong>Goal:</strong> Destroy the enemy <span class="text-yellow-400">Essence</span> (King).</p>
                    <p><strong>Phases:</strong> Day (+Range Solari), Night (+Range Lunari), Eclipse (Max Range).</p>
                </div>
            </div>

            <!-- Difficulty Select (Hidden by default) -->
            <div id="difficultyMenu" class="hidden space-y-4">
                <h3 class="text-2xl text-gray-200 mb-4 fantasy-font">Select Difficulty</h3>
                
                <button onclick="startGame('pve', 'easy')" class="btn-fantasy w-full bg-green-600/80 hover:bg-green-500 text-white font-bold py-3 px-6 rounded-lg shadow-md flex items-center justify-between group">
                    <span class="fantasy-font">Apprentice</span>
                    <span class="text-xs text-gray-200 opacity-0 group-hover:opacity-100 transition-opacity">Easy</span>
                </button>
                
                <button onclick="startGame('pve', 'medium')" class="btn-fantasy w-full bg-yellow-600/80 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-lg shadow-md flex items-center justify-between group">
                    <span class="fantasy-font">Guardian</span>
                    <span class="text-xs text-gray-200 opacity-0 group-hover:opacity-100 transition-opacity">Medium</span>
                </button>
                
                <button onclick="startGame('pve', 'hard')" class="btn-fantasy w-full bg-red-700/80 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-md flex items-center justify-between group">
                    <span class="fantasy-font">Celestial</span>
                    <span class="text-xs text-gray-200 opacity-0 group-hover:opacity-100 transition-opacity">Hard</span>
                </button>

                <button onclick="hideDifficultySelect()" class="mt-4 text-gray-400 hover:text-white underline text-sm">Back</button>
            </div>
        </div>
    </div>

    <!-- Modal: Victory -->
    <div id="victoryModal" class="hidden absolute inset-0 z-50 flex items-center justify-center bg-black/90 backdrop-blur-md">
        <div class="glass-panel p-10 rounded-2xl text-center animate-bounce-in">
            <h2 id="winnerText" class="text-6xl mb-4 fantasy-font text-yellow-400">Solari Victory!</h2>
            <p class="text-gray-300 mb-8">The cycle is broken.</p>
            <button onclick="location.reload()" class="border-2 border-white/50 hover:bg-white/20 text-white font-bold py-2 px-6 rounded-full transition-colors">
                Main Menu
            </button>
        </div>
    </div>

    <!-- Game Header -->
    <div class="w-full max-w-4xl flex justify-between items-center px-6 py-4 mb-4 glass-panel rounded-xl mx-4 mt-4 z-10">
        <div class="flex flex-col w-1/3">
            <span class="text-xs uppercase tracking-widest text-gray-300">Phase</span>
            <div class="flex items-center gap-2">
                <span id="phaseIcon" class="text-3xl">üåÖ</span>
                <span id="phaseName" class="text-xl md:text-2xl font-bold fantasy-font">Dawn</span>
            </div>
        </div>
        
        <div class="flex flex-col items-center w-1/3">
            <div class="text-xs uppercase tracking-widest text-gray-300">Turn</div>
            <div id="turnCounter" class="text-3xl font-bold">1</div>
        </div>

        <div class="flex flex-col items-end w-1/3">
            <span class="text-xs uppercase tracking-widest text-gray-300">Active</span>
            <div class="flex items-center gap-2">
                <div id="aiLoader" class="loader hidden"></div>
                <span id="activePlayer" class="text-xl font-bold text-yellow-400 text-right">Solari</span>
            </div>
        </div>
    </div>

    <!-- Main Game Area -->
    <div class="relative w-full max-w-2xl aspect-square p-4">
        <!-- The Grid -->
        <div id="gameBoard" class="board-container grid grid-cols-6 grid-rows-6 gap-1 w-full h-full bg-black/30 p-2 rounded-lg border-2 border-white/10 shadow-2xl">
            <!-- Tiles generated by JS -->
        </div>
    </div>

    <!-- Footer / Stats -->
    <div class="mt-6 w-full max-w-4xl glass-panel rounded-xl p-4 flex justify-between items-center z-10 mx-4 mb-4">
        <div id="infoPanel" class="text-sm text-gray-200">
            Hover over a unit to see details.
        </div>
        <div class="flex gap-4 text-xs md:text-sm">
             <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-yellow-500"></div> Solari
            </div>
            <div class="flex items-center gap-2">
                <div class="w-3 h-3 rounded-full bg-blue-500"></div> Lunari
            </div>
        </div>
    </div>

    <script>
        // --- Audio & Haptics Engine ---
        const SFX = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (AudioContext) {
                        this.ctx = new AudioContext();
                    }
                }
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            vibrate: function(pattern) {
                if (navigator.vibrate) {
                    navigator.vibrate(pattern);
                }
            },
            play: function(type) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);

                switch (type) {
                    case 'select':
                        // High, sharp blip
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(600, t);
                        osc.frequency.exponentialRampToValueAtTime(1000, t + 0.1);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
                        osc.start(t);
                        osc.stop(t + 0.1);
                        this.vibrate(5);
                        break;
                    
                    case 'move':
                        // Soft whoosh
                        osc.type = 'triangle';
                        osc.frequency.setValueAtTime(300, t);
                        osc.frequency.linearRampToValueAtTime(100, t + 0.15);
                        gain.gain.setValueAtTime(0.1, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.15);
                        osc.start(t);
                        osc.stop(t + 0.15);
                        this.vibrate(10);
                        break;
                        
                    case 'attack':
                        // Crunch/Impact
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(150, t);
                        osc.frequency.exponentialRampToValueAtTime(40, t + 0.2);
                        gain.gain.setValueAtTime(0.15, t);
                        gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
                        osc.start(t);
                        osc.stop(t + 0.2);
                        this.vibrate([20, 50, 20]);
                        break;
                        
                    case 'phase':
                        // Shimmer
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, t);
                        osc.frequency.linearRampToValueAtTime(600, t + 0.5);
                        gain.gain.setValueAtTime(0.05, t);
                        gain.gain.linearRampToValueAtTime(0, t + 0.5);
                        osc.start(t);
                        osc.stop(t + 0.5);
                        break;
                    
                    case 'win':
                        // Victory Arpeggio
                        const now = t;
                        [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                            const o = this.ctx.createOscillator();
                            const g = this.ctx.createGain();
                            o.connect(g);
                            g.connect(this.ctx.destination);
                            o.type = 'triangle';
                            o.frequency.value = freq;
                            g.gain.setValueAtTime(0.1, now + i*0.1);
                            g.gain.exponentialRampToValueAtTime(0.01, now + i*0.1 + 0.4);
                            o.start(now + i*0.1);
                            o.stop(now + i*0.1 + 0.4);
                        });
                        this.vibrate([100, 50, 100, 50, 200]);
                        break;
                }
            }
        };

        // --- Game Config & Constants ---
        const BOARD_SIZE = 6;
        
        const PHASES = [
            { name: "Dawn", icon: "üåÖ", style: "bg-phase-dawn", solariMod: 0, lunariMod: 0, desc: "Balance restored." },
            { name: "Day", icon: "‚òÄÔ∏è", style: "bg-phase-day", solariMod: 1, lunariMod: -1, desc: "Solari +1 Range." },
            { name: "Dusk", icon: "üåá", style: "bg-phase-dusk", solariMod: 0, lunariMod: 0, desc: "The light fades." },
            { name: "Night", icon: "üåô", style: "bg-phase-night", solariMod: -1, lunariMod: 1, desc: "Lunari +1 Range." },
            { name: "Eclipse", icon: "üåë", style: "bg-phase-eclipse", solariMod: 1, lunariMod: 1, desc: "CHAOS! Max range!" }
        ];

        const UNIT_TYPES = {
            essence: { name: "Essence", hp: 1, baseRange: 1, moveType: 'omni', value: 1000, desc: "Life source." },
            ray: { name: "Ray", hp: 1, baseRange: 2, moveType: 'linear', value: 30, desc: "Linear striker." },
            orbit: { name: "Orbit", hp: 1, baseRange: 2, moveType: 'diagonal', value: 30, desc: "Diagonal guard." }
        };

        const SVGS = {
            solari: {
                essence: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-lg"><circle cx="50" cy="50" r="40" fill="url(#sunGradient)" /><circle cx="50" cy="50" r="30" stroke="white" stroke-width="3" fill="none"/><path d="M50 10 L50 90 M10 50 L90 50" stroke="white" stroke-width="4"/><defs><radialGradient id="sunGradient"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#b45309"/></radialGradient></defs></svg>`,
                ray: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md"><path d="M50 15 L85 85 L50 70 L15 85 Z" fill="#f59e0b" stroke="white" stroke-width="2"/></svg>`,
                orbit: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md"><rect x="25" y="25" width="50" height="50" rx="10" fill="#d97706" stroke="white" stroke-width="2"/><circle cx="50" cy="50" r="15" fill="white"/></svg>`
            },
            lunari: {
                essence: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-lg"><path d="M60 10 A 40 40 0 1 1 60 90 A 30 30 0 1 0 60 10" fill="url(#moonGradient)" stroke="white" stroke-width="2"/><defs><linearGradient id="moonGradient" x1="0%" y1="0%" x2="100%" y2="100%"><stop offset="0%" stop-color="#60a5fa"/><stop offset="100%" stop-color="#1e3a8a"/></linearGradient></defs></svg>`,
                ray: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md"><path d="M50 15 L85 85 L50 70 L15 85 Z" fill="#3b82f6" stroke="white" stroke-width="2" transform="rotate(180 50 50)"/></svg>`,
                orbit: `<svg viewBox="0 0 100 100" class="w-full h-full drop-shadow-md"><circle cx="50" cy="50" r="30" fill="none" stroke="#60a5fa" stroke-width="6"/><circle cx="50" cy="50" r="15" fill="#1d4ed8"/></svg>`
            }
        };

        // --- Game State ---
        let gameState = {
            board: [],
            turn: 1,
            currentPlayer: 'solari', 
            phaseIndex: 0,
            selectedPiece: null,
            gameOver: false,
            mode: 'pvp', // 'pvp' or 'pve'
            difficulty: 'easy', // 'easy', 'medium', 'hard'
            cpuFaction: 'lunari',
            isProcessingTurn: false
        };

        // --- Menu Logic ---
        function showDifficultySelect() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('difficultyMenu').classList.remove('hidden');
        }

        function hideDifficultySelect() {
            document.getElementById('difficultyMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
        }

        function startGame(mode, difficulty = 'easy') {
            SFX.init(); // Initialize Audio Context on user interaction
            gameState.mode = mode;
            gameState.difficulty = difficulty;
            document.getElementById('startModal').classList.add('hidden');
            
            initBoard();
            gameState.turn = 1;
            gameState.phaseIndex = 0;
            gameState.currentPlayer = 'solari';
            gameState.gameOver = false;
            gameState.isProcessingTurn = false;
            
            renderBoard();
            updatePhaseUI();
        }

        // --- Board Logic ---
        function initBoard() {
            gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(null));

            // Lunari (Top - Now CPU/Opponent)
            placePiece(0, 2, 'lunari', 'essence');
            placePiece(0, 1, 'lunari', 'orbit');
            placePiece(0, 3, 'lunari', 'orbit');
            placePiece(0, 0, 'lunari', 'ray');
            placePiece(0, 5, 'lunari', 'ray');
            placePiece(1, 2, 'lunari', 'ray'); // Vanguard

            // Solari (Bottom - Now Player)
            placePiece(5, 3, 'solari', 'essence');
            placePiece(5, 2, 'solari', 'orbit');
            placePiece(5, 4, 'solari', 'orbit');
            placePiece(5, 0, 'solari', 'ray');
            placePiece(5, 5, 'solari', 'ray');
            placePiece(4, 3, 'solari', 'ray'); // Vanguard
        }

        function placePiece(r, c, faction, type) {
            gameState.board[r][c] = {
                faction: faction,
                type: type,
                id: `${faction}-${type}-${r}-${c}`
            };
        }

        // --- Core Rules (Pure Functions where possible for AI) ---

        function getPhaseFromTurn(turnNumber) {
            // Change phase every 4 turns
            const turnsPerPhase = 4;
            const totalPhases = PHASES.length;
            return Math.floor((turnNumber - 1) / turnsPerPhase) % totalPhases;
        }

        function getUnitRange(piece, phaseIndex) {
            const phase = PHASES[phaseIndex];
            const mod = piece.faction === 'solari' ? phase.solariMod : phase.lunariMod;
            const base = UNIT_TYPES[piece.type].baseRange;
            let final = base + mod;
            if (final < 1) final = 1;
            if (phaseIndex === 4) final = 4; // Eclipse
            return final;
        }

        function getValidMoves(r, c, board, phaseIndex) {
            const piece = board[r][c];
            if (!piece) return [];
            
            const moves = [];
            const range = getUnitRange(piece, phaseIndex);
            const type = UNIT_TYPES[piece.type].moveType;

            const directions = [];
            if (type === 'linear' || type === 'omni') directions.push([0, 1], [0, -1], [1, 0], [-1, 0]);
            if (type === 'diagonal' || type === 'omni') directions.push([1, 1], [1, -1], [-1, 1], [-1, -1]);

            for (let d of directions) {
                for (let i = 1; i <= range; i++) {
                    const nr = r + (d[0] * i);
                    const nc = c + (d[1] * i);

                    if (nr < 0 || nr >= BOARD_SIZE || nc < 0 || nc >= BOARD_SIZE) break;

                    const target = board[nr][nc];

                    if (target === null) {
                        moves.push({r: nr, c: nc, type: 'move', fromR: r, fromC: c});
                    } else {
                        if (target.faction !== piece.faction) {
                            moves.push({r: nr, c: nc, type: 'attack', fromR: r, fromC: c, targetVal: UNIT_TYPES[target.type].value});
                        }
                        break; // Blocked
                    }
                }
            }
            return moves;
        }

        function getAllMoves(board, faction, phaseIndex) {
            let allMoves = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (board[r][c] && board[r][c].faction === faction) {
                        allMoves = allMoves.concat(getValidMoves(r, c, board, phaseIndex));
                    }
                }
            }
            return allMoves;
        }

        // --- Interaction ---

        function handleTileClick(r, c) {
            if (gameState.gameOver || gameState.isProcessingTurn) return;

            // Block input if it's CPU turn
            if (gameState.mode === 'pve' && gameState.currentPlayer === gameState.cpuFaction) return;

            const clickedPiece = gameState.board[r][c];
            const isCurrentFaction = clickedPiece && clickedPiece.faction === gameState.currentPlayer;

            // Select
            if (isCurrentFaction) {
                gameState.selectedPiece = { r, c };
                renderBoard();
                updateInfoPanel(clickedPiece);
                SFX.play('select'); // Sound Trigger
                return;
            }

            // Move
            if (gameState.selectedPiece) {
                // Use current state for validation
                const validMoves = getValidMoves(gameState.selectedPiece.r, gameState.selectedPiece.c, gameState.board, gameState.phaseIndex);
                const move = validMoves.find(m => m.r === r && m.c === c);

                if (move) {
                    executeMove(move);
                } else {
                    gameState.selectedPiece = null;
                    renderBoard();
                    document.getElementById('infoPanel').innerText = "Hover over a unit to see details.";
                }
            }
        }

        function executeMove(move) {
            const piece = gameState.board[move.fromR][move.fromC];
            const target = gameState.board[move.r][move.c];

            // Sound Trigger based on move type
            if (move.type === 'attack') {
                SFX.play('attack');
            } else {
                SFX.play('move');
            }

            // Capture logic
            if (target && target.type === 'essence') {
                endGame(piece.faction);
                return;
            }

            // Move piece
            gameState.board[move.r][move.c] = piece;
            gameState.board[move.fromR][move.fromC] = null;
            gameState.selectedPiece = null;

            // Render move effect
            renderBoard();

            // Next Turn
            endTurn();
        }

        function endTurn() {
            gameState.turn++;
            gameState.currentPlayer = gameState.currentPlayer === 'solari' ? 'lunari' : 'solari';
            
            // Recalculate phase based on new turn
            const oldPhase = gameState.phaseIndex;
            gameState.phaseIndex = getPhaseFromTurn(gameState.turn);

            if (oldPhase !== gameState.phaseIndex) {
                SFX.play('phase'); // Phase change sound
            }

            updatePhaseUI();
            
            // Check for AI Turn
            if (gameState.mode === 'pve' && gameState.currentPlayer === gameState.cpuFaction && !gameState.gameOver) {
                gameState.isProcessingTurn = true;
                updatePhaseUI(); // Show loader
                setTimeout(aiTurn, 1000); // Delay for realism
            } else {
                gameState.isProcessingTurn = false;
                updatePhaseUI();
            }
        }

        // --- AI ENGINE ---

        function aiTurn() {
            const move = getBestMove();
            if (move) {
                executeMove(move);
            } else {
                // No moves possible? (Stalemateish) - Just skip turn or resign?
                // For this game, let's just pass turn.
                console.log("AI has no moves.");
                gameState.isProcessingTurn = false;
                endTurn();
            }
        }

        function getBestMove() {
            const diff = gameState.difficulty;
            const faction = gameState.cpuFaction;
            const board = gameState.board;
            const phase = gameState.phaseIndex;

            if (diff === 'easy') {
                // Strategy: Random valid move.
                const moves = getAllMoves(board, faction, phase);
                if (moves.length === 0) return null;
                return moves[Math.floor(Math.random() * moves.length)];
            }

            if (diff === 'medium') {
                // Strategy: Greedy. 
                // 1. Can I kill Essence? Do it.
                // 2. Can I kill anything else? Do it.
                // 3. Otherwise random.
                const moves = getAllMoves(board, faction, phase);
                if (moves.length === 0) return null;

                // Sort by target value (Attack > Move)
                moves.sort((a, b) => {
                    const valA = a.type === 'attack' ? a.targetVal : 0;
                    const valB = b.type === 'attack' ? b.targetVal : 0;
                    return valB - valA;
                });
                
                // Add a little randomness to the top choices so it's not perfectly predictable
                const topMoves = moves.filter(m => {
                    const val = m.type === 'attack' ? m.targetVal : 0;
                    return val === (moves[0].type === 'attack' ? moves[0].targetVal : 0);
                });
                
                return topMoves[Math.floor(Math.random() * topMoves.length)];
            }

            if (diff === 'hard') {
                // Strategy: Minimax Depth 3 with Alpha-Beta Pruning
                // Simplified for performance in JS main thread
                const best = minimax(board, 3, true, -Infinity, Infinity, gameState.turn);
                return best.move;
            }
        }

        // --- Minimax Implementation ---
        
        // Deep clone 2D array
        function cloneBoard(board) {
            return board.map(row => row.slice());
        }

        // Evaluation Function
        function evaluateBoard(board, turnNumber) {
            let score = 0;
            const phase = getPhaseFromTurn(turnNumber);
            const cpu = gameState.cpuFaction;
            const player = cpu === 'solari' ? 'lunari' : 'solari';

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const p = board[r][c];
                    if (!p) continue;

                    // Material Value
                    let val = UNIT_TYPES[p.type].value;
                    
                    // Positional Heuristic: Slight bonus for advancing (depending on faction side)
                    // Lunari starts at top (row 0), wants to go down (row 5)
                    // Solari starts at bottom (row 5), wants to go up (row 0)
                    if (p.faction === 'lunari') val += r; 
                    if (p.faction === 'solari') val += (5 - r);

                    if (p.faction === cpu) score += val;
                    else score -= val;
                }
            }
            return score;
        }

        function minimax(board, depth, isMaximizing, alpha, beta, currentTurn) {
            // Check terminal state (Essence Missing)
            // Optimization: Just check if King was captured in previous move? 
            // We'll iterate board to find Kings.
            let cpuKing = false;
            let playerKing = false;
            for(let r=0; r<BOARD_SIZE; r++) {
                for(let c=0; c<BOARD_SIZE; c++) {
                    if(board[r][c] && board[r][c].type === 'essence') {
                        if(board[r][c].faction === gameState.cpuFaction) cpuKing = true;
                        else playerKing = true;
                    }
                }
            }
            
            if (!playerKing) return { score: 10000 }; // CPU Wins
            if (!cpuKing) return { score: -10000 }; // CPU Loses
            if (depth === 0) return { score: evaluateBoard(board, currentTurn) };

            const phase = getPhaseFromTurn(currentTurn);
            const faction = isMaximizing ? gameState.cpuFaction : (gameState.cpuFaction === 'solari' ? 'lunari' : 'solari');
            
            const moves = getAllMoves(board, faction, phase);
            
            if (moves.length === 0) return { score: isMaximizing ? -1000 : 1000 }; // No moves is bad

            // Move Ordering for Efficiency (Capture moves first)
            moves.sort((a, b) => (b.type === 'attack' ? 1 : 0) - (a.type === 'attack' ? 1 : 0));

            let bestMove = null;

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of moves) {
                    const newBoard = cloneBoard(board);
                    // Execute simulated move
                    newBoard[move.r][move.c] = newBoard[move.fromR][move.fromC];
                    newBoard[move.fromR][move.fromC] = null;
                    
                    const eval = minimax(newBoard, depth - 1, false, alpha, beta, currentTurn + 1).score;
                    
                    if (eval > maxEval) {
                        maxEval = eval;
                        bestMove = move;
                    }
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return { score: maxEval, move: bestMove };
            } else {
                let minEval = Infinity;
                for (let move of moves) {
                    const newBoard = cloneBoard(board);
                    // Execute simulated move
                    newBoard[move.r][move.c] = newBoard[move.fromR][move.fromC];
                    newBoard[move.fromR][move.fromC] = null;

                    const eval = minimax(newBoard, depth - 1, true, alpha, beta, currentTurn + 1).score;
                    
                    if (eval < minEval) {
                        minEval = eval;
                        bestMove = move;
                    }
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return { score: minEval, move: bestMove };
            }
        }

        // --- Rendering & UI ---

        function updatePhaseUI() {
            const phase = PHASES[gameState.phaseIndex];
            
            const body = document.getElementById('gameBody');
            body.className = `h-screen w-screen flex flex-col items-center justify-center text-white transition-colors duration-1000 ${phase.style}`;

            document.getElementById('phaseIcon').innerText = phase.icon;
            document.getElementById('phaseName').innerText = phase.name;
            document.getElementById('turnCounter').innerText = gameState.turn;
            
            const pText = document.getElementById('activePlayer');
            const loader = document.getElementById('aiLoader');

            let displayText = "";
            let colorClass = "";

            if (gameState.currentPlayer === 'solari') {
                displayText = "SOLARI";
                colorClass = "text-yellow-400";
            } else {
                displayText = "LUNARI";
                colorClass = "text-blue-400";
            }

            if (gameState.isProcessingTurn) {
                loader.classList.remove('hidden');
                displayText = "Thinking...";
                pText.classList.add('animate-pulse');
            } else {
                loader.classList.add('hidden');
                pText.classList.remove('animate-pulse');
            }

            pText.innerText = displayText;
            pText.className = `text-xl font-bold text-right ${colorClass}`;

            document.getElementById('infoPanel').innerHTML = `<strong>${phase.name}:</strong> ${phase.desc}`;
        }

        function endGame(winner) {
            gameState.gameOver = true;
            renderBoard();
            
            SFX.play('win'); // Win Sound Trigger
            
            const modal = document.getElementById('victoryModal');
            const text = document.getElementById('winnerText');
            
            modal.classList.remove('hidden');
            text.innerText = winner.toUpperCase() + " VICTORY!";
            text.className = `text-6xl mb-4 fantasy-font ${winner === 'solari' ? 'text-yellow-400' : 'text-blue-400'}`;
        }

        function renderBoard() {
            const boardEl = document.getElementById('gameBoard');
            boardEl.innerHTML = '';

            let validMoves = [];
            if (gameState.selectedPiece) {
                validMoves = getValidMoves(gameState.selectedPiece.r, gameState.selectedPiece.c, gameState.board, gameState.phaseIndex);
            }

            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const tile = document.createElement('div');
                    tile.className = `tile w-full h-full rounded bg-white/5 border border-white/5 relative flex items-center justify-center cursor-pointer`;
                    
                    if ((r + c) % 2 === 1) tile.classList.add('bg-white/10');

                    if (gameState.selectedPiece && gameState.selectedPiece.r === r && gameState.selectedPiece.c === c) {
                        tile.classList.add('selected-tile');
                    }

                    const move = validMoves.find(m => m.r === r && m.c === c);
                    if (move) {
                        if (move.type === 'attack') {
                            tile.classList.add('highlight-attack');
                        } else {
                            tile.classList.add('highlight-move');
                            const dot = document.createElement('div');
                            dot.className = "absolute w-3 h-3 bg-green-400 rounded-full opacity-50";
                            tile.appendChild(dot);
                        }
                    }

                    const piece = gameState.board[r][c];
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.className = 'piece w-4/5 h-4/5';
                        pieceEl.innerHTML = SVGS[piece.faction][piece.type];
                        tile.appendChild(pieceEl);
                        tile.onmouseenter = () => updateInfoPanel(piece);
                    }

                    tile.onclick = () => handleTileClick(r, c);
                    boardEl.appendChild(tile);
                }
            }
        }

        function updateInfoPanel(piece) {
            const panel = document.getElementById('infoPanel');
            if (!piece) return;
            
            const def = UNIT_TYPES[piece.type];
            // We need to pass the current phase to get correct range in the UI hover
            const range = getUnitRange(piece, gameState.phaseIndex);
            const factionColor = piece.faction === 'solari' ? 'text-yellow-400' : 'text-blue-400';
            
            panel.innerHTML = `<span class="${factionColor} font-bold uppercase">${piece.faction} ${def.name}</span> | Range: <strong>${range}</strong> | ${def.desc}`;
        }

        // Render board behind modal on load
        initBoard();
        renderBoard();
    </script>
</body>
</html>
